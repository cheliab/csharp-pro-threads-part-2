// Использование ключевого слова volatile
// (отключение оптимизации JIT компилятора)

/*
    Ключевое слово volatile можно применять к полям следующих типов:
    1. Ссылочные типы
    2. Типы, такие как sbyte, byte, short, ushort, int, uint, char, float и bool.
    3. Тип перечисления с одним из следующих базовых типов: byte, sbyte, short, ushort, int или uint.
    4. Параметры универсильных типов, являющиеся ссылочными типами.

    Ключевое слово valatile можно применить только к полям класса или стуртуры.
    Локальные переменные не могут быть объявлены как volatile.

    Поля, помеченные ключевым словом volatile, не проходят оптимизацию компилятором.
*/

public class Program
{
    static volatile bool stop; // Без JIT оптимизации
    //static bool stop;

    public static void Main()
    {
        Console.WriteLine("Main: Start");

        Thread thread = new Thread(Function);
        thread.Start();

        Thread.Sleep(2000);

        stop = true;
        Console.WriteLine("Main: ожидание завершения вторичного потока");
        thread.Join();
    }

    private static void Function()
    {
        int x = 0;

        while (!stop) // Статическое условие (считается всегда - true)
        {
            x++;
        }

        /*
        При компиляции данного метода JIT компилятор обнаружит,
        что переменная stop не меняется (она изменяется только в Main).

        JIT компилятор может сделать код, заранее проверяющий условие цикла while,
        а переменная stop принимает учатие в формировании условного выраженияб
        но при это переменная stop не изменяется в методе Worker.

        Из этого оптимизатор делает предположение о том что условие статично,
        (оптимизатор не учитывает, что переменная может измениться из другого потока)
        потому что официально до определенного времени поток блы просто трюком.

        Оптимизатор пытается угодить буферу предсказаний переходов CPU.
        */

        // !!! [Оптимизация не производится в режиме отладки - DEBUG] !!!

        // - Если добавить к stop "volatile" - то JIT компилятор не будет выполнять оптимизацию

        // --- Пример оптимизированного кода (нет признака volatile) ---

        //if (stop != true)
        //{
        //    Label:
        //    x++;
        //    goto Label;
        //}

        // --- Пример оптимизированного кода (нет признака volatile) ---

        Console.WriteLine($"Function: поток остановлен при x = {x}");
    }
}
